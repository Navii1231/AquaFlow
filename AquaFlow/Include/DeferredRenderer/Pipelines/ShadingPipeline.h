#pragma once
#include "DeferredPipeline.h"

AQUA_BEGIN

struct ShadingPipelineVertex
{
	glm::vec3 Vertex;
	glm::vec2 TexCoord;
};

using ShadingPipelineQuad = std::array<ShadingPipelineVertex, 4>;

enum class ShadingModel
{
	ePBR                  = 1,
	BlinnPhong            = 2,
};

// An instance of this class is generated by the material system and also material system
// will keep track of this class internally

class ShadingPipeline : public vkLib::GraphicsPipeline
{
public:
	ShadingPipeline() = default;

public: // should be public
	ShadingPipeline(const vkLib::PShader& shader, vkLib::Framebuffer shadingBuffer);

	template <typename Fn>
	void TraverseImageResources(Fn&& fn);

	template <typename Fn>
	void TraverseStorageBuffers(Fn&& fn);

	template <typename Fn>
	void TraverseUniformBuffers(Fn&& fn);

	friend class MaterialBuilder;

	~ShadingPipeline() = default;

	virtual void UpdateDescriptors();

	// operator[] is enough here, remove these functions
	void SetGeometry(const FragmentResourceMap& geometry);
	void SetGeometryDescLocation(const std::string& tag, const glm::uvec3& location);

	Resource& operator[](const std::string& tag) { return mResources[tag]; }
	const Resource& operator[](const std::string& tag) const { return mResources.at(tag); }

private:
	vkLib::Image mOutImage;

	ResourceMap mGeometry;
	ResourceMap mResources;

private:
	void SetupBasicConfig(vkLib::GraphicsPipelineConfig& config);

	virtual size_t GetIndexCount() const override { return 6; }

	virtual void BindVertexBuffers(vk::CommandBuffer commandBuffer) const override { }
	virtual void BindIndexBuffer(vk::CommandBuffer commandBuffer) const override { }

};

template <typename Fn>
void AQUA_NAMESPACE::ShadingPipeline::TraverseImageResources(Fn&& fn)
{
	for (auto& [name, resource] : mGeometry)
	{
		fn(name, resource.Location, resource.ImageView);
	}

	for (auto& [name, resource] : mResources)
	{
		if (name.front() == '@')
			fn(name, resource.Location, resource.ImageView);
	}
}

template <typename Fn>
void AQUA_NAMESPACE::ShadingPipeline::TraverseStorageBuffers(Fn&& fn)
{
	for (auto& [name, resource] : mGeometry)
	{
		if (name.front() == '$')
			fn(name, resource.Location, resource.Buffer);
	}
}

template <typename Fn>
void AQUA_NAMESPACE::ShadingPipeline::TraverseUniformBuffers(Fn&& fn)
{
	for (auto& [name, resource] : mGeometry)
	{
		if (name.front() == '#')
			fn(name, resource.Location, resource.Buffer);
	}
}

AQUA_END
